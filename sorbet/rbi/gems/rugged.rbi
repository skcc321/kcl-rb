# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rugged/all/rugged.rbi
#
# rugged-1.2.0

module Rugged
  def __cache_usage__; end
  def dotgit_attributes?(arg0); end
  def dotgit_ignore?(arg0); end
  def dotgit_modules?(arg0); end
  def features; end
  def hex_to_raw(arg0); end
  def libgit2_version; end
  def minimize_oid(*arg0); end
  def prettify_message(*arg0); end
  def raw_to_hex(arg0); end
  def self.__cache_usage__; end
  def self.dotgit_attributes?(arg0); end
  def self.dotgit_ignore?(arg0); end
  def self.dotgit_modules?(arg0); end
  def self.features; end
  def self.hex_to_raw(arg0); end
  def self.libgit2_version; end
  def self.minimize_oid(*arg0); end
  def self.prettify_message(*arg0); end
  def self.raw_to_hex(arg0); end
  def self.signature_from_buffer(*arg0); end
  def self.valid_full_oid?(arg0); end
  def signature_from_buffer(*arg0); end
  def valid_full_oid?(arg0); end
end
class Rugged::Reference
  def branch?; end
  def canonical_name; end
  def inspect; end
  def log; end
  def log?; end
  def name; end
  def peel; end
  def remote?; end
  def resolve; end
  def self.valid_name?(arg0); end
  def tag?; end
  def target; end
  def target_id; end
  def type; end
end
class Rugged::ReferenceCollection
  def [](arg0); end
  def create(*arg0); end
  def delete(arg0); end
  def each(*arg0); end
  def each_name(*arg0); end
  def exist?(arg0); end
  def exists?(arg0); end
  def initialize(arg0); end
  def move(*arg0); end
  def rename(*arg0); end
  def update(*arg0); end
end
class Rugged::Object
  def <=>(other); end
  def ==(arg0); end
  def create_note(arg0); end
  def notes(*arg0); end
  def oid; end
  def read_raw; end
  def remove_note(*arg0); end
  def self.lookup(arg0, arg1); end
  def self.new(arg0, arg1); end
  def self.rev_parse(arg0, arg1); end
  def self.rev_parse_oid(arg0, arg1); end
  def type; end
end
class Rugged::Commit < Rugged::Object
  def amend(arg0); end
  def author; end
  def committer; end
  def diff(*args); end
  def diff_workdir(options = nil); end
  def epoch_time; end
  def header; end
  def header_field(arg0); end
  def header_field?(field); end
  def inspect; end
  def message; end
  def modify(new_args, update_ref = nil); end
  def parent_ids; end
  def parent_oids; end
  def parents; end
  def self.create(arg0, arg1); end
  def self.create_to_s(arg0, arg1); end
  def self.create_with_signature(*arg0); end
  def self.extract_signature(*arg0); end
  def self.prettify_message(msg, strip_comments = nil); end
  def summary; end
  def time; end
  def to_hash; end
  def to_mbox(*arg0); end
  def trailers; end
  def tree; end
  def tree_id; end
  def tree_oid; end
end
class Rugged::Tree < Rugged::Object
  def [](arg0); end
  def count; end
  def count_recursive(*arg0); end
  def diff(other = nil, options = nil); end
  def diff_workdir(*arg0); end
  def each; end
  def each_blob; end
  def each_tree; end
  def get_entry(arg0); end
  def get_entry_by_oid(arg0); end
  def inspect; end
  def length; end
  def merge(*arg0); end
  def owner; end
  def path(arg0); end
  def repo; end
  def self.diff(repo, tree, other_tree = nil, options = nil); end
  def self.diff_tree_to_index(arg0, arg1, arg2, arg3); end
  def self.diff_tree_to_tree(arg0, arg1, arg2, arg3); end
  def self.empty(arg0); end
  def update(arg0); end
  def walk(arg0); end
  def walk_blobs(mode = nil); end
  def walk_trees(mode = nil); end
  include Enumerable
end
class Rugged::Tree::Builder
  def <<(arg0); end
  def [](arg0); end
  def clear; end
  def insert(arg0); end
  def reject!; end
  def remove(arg0); end
  def self.new(*arg0); end
  def write; end
end
class Rugged::Tag < Rugged::Reference
  def annotated?; end
  def annotation; end
  def name; end
  def self.extract_signature(repo, oid, prefix = nil); end
  def target; end
end
class Rugged::Tag::Annotation < Rugged::Object
  def inspect; end
  def message; end
  def modify(new_args, force = nil); end
  def name; end
  def self.prettify_message(msg, strip_comments = nil); end
  def tagger; end
  def target; end
  def target_id; end
  def target_oid; end
  def target_type; end
  def to_hash; end
end
class Rugged::TagCollection
  def [](arg0); end
  def create(*arg0); end
  def create_annotation(arg0, arg1, arg2); end
  def delete(arg0); end
  def each(*arg0); end
  def each_name(*arg0); end
  def initialize(arg0); end
end
class Rugged::Blob < Rugged::Object
  def binary?; end
  def content(*arg0); end
  def diff(*arg0); end
  def hashsig(options = nil); end
  def loc; end
  def self.from_buffer(arg0, arg1); end
  def self.from_disk(arg0, arg1); end
  def self.from_io(*arg0); end
  def self.from_workdir(arg0, arg1); end
  def self.merge_files(*arg0); end
  def self.to_buffer(*arg0); end
  def similarity(other); end
  def size; end
  def sloc; end
  def text(*arg0); end
end
class Rugged::Blob::HashSignature
  def self.compare(arg0, arg1); end
  def self.new(*arg0); end
end
class Rugged::Index
  def <<(arg0); end
  def [](*arg0); end
  def add(arg0); end
  def add_all(*arg0); end
  def clear; end
  def conflict_add(arg0); end
  def conflict_cleanup; end
  def conflict_get(arg0); end
  def conflict_remove(arg0); end
  def conflicts; end
  def conflicts?; end
  def count; end
  def diff(*args); end
  def diff_index_to_workdir(arg0); end
  def diff_tree_to_index(arg0, arg1); end
  def each; end
  def get(*arg0); end
  def merge_file(*arg0); end
  def read_tree(arg0); end
  def reload; end
  def remove(*arg0); end
  def remove_all(*arg0); end
  def remove_dir(*arg0); end
  def self.new(*arg0); end
  def to_s; end
  def update(arg0); end
  def update_all(*arg0); end
  def write; end
  def write_tree(*arg0); end
  include Enumerable
end
class Rugged::Repository
  def ahead_behind(arg0, arg1); end
  def apply(*arg0); end
  def attributes(path, options = nil); end
  def bare?; end
  def blob_at(revision, path); end
  def branches; end
  def checkout(target, options = nil); end
  def checkout_head(*arg0); end
  def checkout_index(*arg0); end
  def checkout_tree(*arg0); end
  def cherrypick(*arg0); end
  def cherrypick_commit(*arg0); end
  def close; end
  def config; end
  def config=(arg0); end
  def create_branch(name, sha_or_ref = nil); end
  def default_notes_ref; end
  def default_signature; end
  def descendant_of?(arg0, arg1); end
  def diff(left, right, opts = nil); end
  def diff_from_buffer(arg0); end
  def diff_workdir(left, opts = nil); end
  def each_id; end
  def each_note(*arg0); end
  def each_status; end
  def empty?; end
  def exists?(arg0); end
  def expand_oids(*arg0); end
  def fetch(remote_or_url, *args, **kwargs); end
  def fetch_attributes(*arg0); end
  def file_status(arg0); end
  def head; end
  def head=(arg0); end
  def head_detached?; end
  def head_unborn?; end
  def ident; end
  def ident=(arg0); end
  def include?(arg0); end
  def index; end
  def index=(arg0); end
  def inspect; end
  def last_commit; end
  def lookup(oid); end
  def merge_analysis(*arg0); end
  def merge_base(*arg0); end
  def merge_bases(*arg0); end
  def merge_commits(*arg0); end
  def namespace; end
  def namespace=(arg0); end
  def path; end
  def path_ignored?(arg0); end
  def push(remote_or_url, *args, **kwargs); end
  def read(arg0); end
  def read_header(arg0); end
  def ref(ref_name); end
  def ref_names(glob = nil); end
  def references; end
  def refs(glob = nil); end
  def remotes; end
  def reset(arg0, arg1); end
  def reset_path(*arg0); end
  def rev_parse(spec); end
  def rev_parse_oid(spec); end
  def revert_commit(*arg0); end
  def self.bare(*arg0); end
  def self.clone_at(*arg0); end
  def self.discover(*arg0); end
  def self.hash_data(arg0, arg1); end
  def self.hash_file(arg0, arg1); end
  def self.init_at(*arg0); end
  def self.new(*arg0); end
  def shallow?; end
  def status(file = nil, &block); end
  def submodules; end
  def tags; end
  def walk(from, sorting = nil, &block); end
  def workdir; end
  def workdir=(arg0); end
  def write(arg0, arg1); end
end
class Rugged::OdbObject
  def data; end
  def len; end
  def oid; end
  def type; end
end
class Rugged::Walker
  def count(*arg0); end
  def each(*arg0); end
  def each_oid(*arg0); end
  def hide(arg0); end
  def push(arg0); end
  def push_range(arg0); end
  def reset; end
  def self.new(arg0); end
  def self.walk(*arg0); end
  def simplify_first_parent; end
  def sorting(arg0); end
  def walk(*arg0); end
  include Enumerable
end
class Rugged::Branch < Rugged::Reference
  def ==(other); end
  def head?; end
  def name; end
  def remote; end
  def remote_name; end
  def upstream; end
  def upstream=(arg0); end
end
class Rugged::BranchCollection
  def [](arg0); end
  def create(*arg0); end
  def delete(arg0); end
  def each(*arg0); end
  def each_name(*arg0); end
  def exist?(arg0); end
  def exists?(arg0); end
  def initialize(arg0); end
  def move(*arg0); end
  def rename(*arg0); end
end
class Rugged::Config
  def [](arg0); end
  def []=(arg0, arg1); end
  def delete(arg0); end
  def each; end
  def each_key; end
  def each_pair; end
  def get(arg0); end
  def get_all(arg0); end
  def self.global; end
  def self.new(arg0); end
  def self.open_global; end
  def snapshot; end
  def store(arg0, arg1); end
  def to_hash; end
  def transaction; end
end
class Rugged::Remote
  def check_connection(*arg0); end
  def fetch(*arg0); end
  def fetch_refspecs; end
  def ls(*arg0); end
  def name; end
  def push(*arg0); end
  def push_refspecs; end
  def push_url; end
  def push_url=(arg0); end
  def url; end
end
class Rugged::RemoteCollection
  def [](arg0); end
  def add_fetch_refspec(arg0, arg1); end
  def add_push_refspec(arg0, arg1); end
  def create(arg0, arg1); end
  def create_anonymous(arg0); end
  def delete(arg0); end
  def each; end
  def each_name; end
  def initialize(arg0); end
  def rename(arg0, arg1); end
  def set_push_url(arg0, arg1); end
  def set_url(arg0, arg1); end
end
class Rugged::Settings
  def [](arg0); end
  def []=(arg0, arg1); end
  def max_cache_size; end
  def self.[](arg0); end
  def self.[]=(arg0, arg1); end
  def self.max_cache_size; end
  def self.used_cache_size; end
  def used_cache_size; end
end
class Rugged::Submodule
  def add_to_index(*arg0); end
  def added_to_index?; end
  def added_to_workdir?; end
  def deleted_from_index?; end
  def deleted_from_workdir?; end
  def dirty_workdir?; end
  def dirty_workdir_index?; end
  def fetch_recurse_submodules?; end
  def finalize_add; end
  def head_oid; end
  def ignore_rule; end
  def in_config?; end
  def in_head?; end
  def in_index?; end
  def in_workdir?; end
  def index_oid; end
  def init(*arg0); end
  def modified_files_in_workdir?; end
  def modified_in_index?; end
  def modified_in_workdir?; end
  def name; end
  def path; end
  def reload; end
  def repository; end
  def status; end
  def sync; end
  def uninitialized?; end
  def unmodified?; end
  def untracked_files_in_workdir?; end
  def update_rule; end
  def url; end
  def workdir_oid; end
end
class Rugged::SubmoduleCollection
  def [](arg0); end
  def add(url, path, options = nil); end
  def clone_submodule(repo, **fetch_options); end
  def each; end
  def initialize(arg0); end
  def setup_add(*arg0); end
  def update(arg0, arg1); end
end
class Rugged::Diff
  def deltas; end
  def each; end
  def each_delta; end
  def each_line(*arg0); end
  def each_patch; end
  def find_similar!(*arg0); end
  def merge!(arg0); end
  def owner; end
  def patch(*arg0); end
  def patches; end
  def size; end
  def sorted_icase?; end
  def stat; end
  def write_patch(*arg0); end
  include Enumerable
end
class Rugged::Patch
  def additions; end
  def bytesize(*arg0); end
  def changes; end
  def count; end
  def deletions; end
  def delta; end
  def diff; end
  def each; end
  def each_hunk; end
  def header; end
  def hunk_count; end
  def hunks; end
  def inspect; end
  def lines(*arg0); end
  def owner; end
  def owner=(arg0); end
  def self.from_strings(*arg0); end
  def size; end
  def stat; end
  def to_s; end
  include Enumerable
end
class Rugged::Diff::Hunk
  def count; end
  def delta; end
  def each; end
  def each_line; end
  def header; end
  def hunk_index; end
  def inspect; end
  def line_count; end
  def lines; end
  def new_lines; end
  def new_start; end
  def old_lines; end
  def old_start; end
  def size; end
end
class Rugged::Blame
  def [](arg0); end
  def count; end
  def each; end
  def for_line(arg0); end
  def self.new(*arg0); end
  def size; end
end
class Rugged::Rebase
  def abort; end
  def commit(*arg0); end
  def finish(arg0); end
  def inmemory_index; end
  def next; end
  def self.new(*arg0); end
end
class Rugged::Diff::Line
  def addition?; end
  def binary?; end
  def content; end
  def content_offset; end
  def context?; end
  def deletion?; end
  def eof_newline_added?; end
  def eof_newline_removed?; end
  def eof_no_newline?; end
  def file_header?; end
  def hunk_header?; end
  def inspect; end
  def line_origin; end
  def new_lineno; end
  def old_lineno; end
end
class Rugged::Diff::Delta
  def added?; end
  def binary; end
  def binary?; end
  def copied?; end
  def deleted?; end
  def diff; end
  def ignored?; end
  def inspect; end
  def modified?; end
  def new_file; end
  def old_file; end
  def owner; end
  def renamed?; end
  def similarity; end
  def status; end
  def status_char; end
  def typechange?; end
  def untracked?; end
end
module Rugged::Credentials
end
class Rugged::Credentials::UserPassword
  def call(url, username_from_url, allowed_types); end
  def initialize(options); end
end
class Rugged::Credentials::SshKey
  def call(url, username_from_url, allowed_types); end
  def initialize(options); end
end
class Rugged::Credentials::SshKeyFromAgent
  def call(url, username_from_url, allowed_types); end
  def initialize(options); end
end
class Rugged::Credentials::Default
  def call(url, username_from_url, allowed_types); end
end
class Rugged::Repository::Attributes
  def [](attribute); end
  def each(&block); end
  def initialize(repository, path, options = nil); end
  def self.parse_opts(opt); end
  def to_h; end
  include Enumerable
end
